{"version":3,"file":"zmodem.js","sources":["../../../src/addons/zmodem/zmodem.ts","../../../node_modules/_browser-pack@6.0.3@browser-pack/_prelude.js"],"sourcesContent":["/**\r\n *\r\n * Allow xterm.js to handle ZMODEM uploads and downloads.\r\n *\r\n * This addon is a wrapper around zmodem.js. It adds the following to the\r\n *  Terminal class:\r\n *\r\n * - function `zmodemAttach(<WebSocket>, <Object>)` - creates a Zmodem.Sentry\r\n *      on the passed WebSocket object. The Object passed is optional and\r\n *      can contain:\r\n *          - noTerminalWriteOutsideSession: Suppress writes from the Sentry\r\n *            object to the Terminal while there is no active Session. This\r\n *            is necessary for compatibility with, for example, the\r\n *            `attach.js` addon.\r\n *\r\n * - event `zmodemDetect` - fired on Zmodem.Sentry’s `on_detect` callback.\r\n *      Passes the zmodem.js Detection object.\r\n *\r\n * - event `zmodemRetract` - fired on Zmodem.Sentry’s `on_retract` callback.\r\n *\r\n * You’ll need to provide logic to handle uploads and downloads.\r\n * See zmodem.js’s documentation for more details.\r\n *\r\n * **IMPORTANT:** After you confirm() a zmodem.js Detection, if you have\r\n *  used the `attach` or `terminado` addons, you’ll need to suspend their\r\n *  operation for the duration of the ZMODEM session. (The demo does this\r\n *  via `detach()` and a re-`attach()`.)\r\n */\r\n\r\nlet Zmodem;\r\n\r\nexport function zmodemAttach(term, ws, opts) {\r\n  if (!opts) opts = {};\r\n\r\n  var senderFunc = function _ws_sender_func(octets) {\r\n    ws.send(new Uint8Array(octets));\r\n  };\r\n\r\n  var zsentry;\r\n\r\n  function _shouldWrite() {\r\n    return !!zsentry.get_confirmed_session() || !opts.noTerminalWriteOutsideSession;\r\n  }\r\n\r\n  zsentry = new Zmodem.Sentry( {\r\n    to_terminal: function _to_terminal(octets) {\r\n      if (_shouldWrite()) {\r\n        term.write(\r\n          String.fromCharCode.apply(String, octets)\r\n        );\r\n      }\r\n    },\r\n\r\n    sender: senderFunc,\r\n\r\n    on_retract: function _on_retract() {\r\n      term.emit('zmodemRetract');\r\n    },\r\n\r\n    on_detect: function _on_detect(detection) {\r\n      term.emit('zmodemDetect', detection);\r\n    },\r\n  } );\r\n\r\n  function handleWSMessage(evt) {\r\n\r\n    //In testing with xterm.js’s demo the first message was\r\n    //always text even if the rest were binary. While that\r\n    //may be specific to xterm.js’s demo, ultimately we\r\n    //should reject anything that isn’t binary.\r\n    if (typeof evt.data === 'string') {\r\n      if (_shouldWrite()) {\r\n        term.write(evt.data);\r\n      }\r\n    }\r\n    else {\r\n      zsentry.consume(evt.data);\r\n    }\r\n  }\r\n\r\n  ws.binaryType = 'arraybuffer';\r\n  ws.addEventListener('message', handleWSMessage);\r\n}\r\n\r\nexport function apply(terminalConstructor) {\r\n  Zmodem = (typeof window == 'object') ? (<any>window).ZModem : {Browser: null};  // Nullify browser for tests\r\n\r\n  terminalConstructor.prototype.zmodemAttach = zmodemAttach.bind(this, this);\r\n  terminalConstructor.prototype.zmodemBrowser = Zmodem.Browser\r\n}\r\n",null],"names":[],"mappings":"ACAA;;;AD6BA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAnDA;AAqDA;AACA;AAEA;AACA;AACA;AALA;;;"}